/*************************************************
File name:   httpsclt.c
Description: 用于处理航信、百旺等税盘与税务局交互的HTTPS协议共用封装
Author:      Zako
Version:     1.0
Date:        2019.12
History:
20220627     为解决SSL连接部分与libevent不兼容，大幅度精简我方代码，由libevent实现SSL连接
*************************************************/
#include "httpsclt.h"
#include "sys/queue.h"

#ifdef _CONSOLE
void SSLkeylogCallback(const SSL *ssl, const char *line)
{
    SSL_CTX *ctx = SSL_get_SSL_CTX(ssl);
    HHTTP hi = SSL_CTX_get_app_data(ctx);
    if (!hi)
        return;
    if (!hi->bioKeylog)
        return;
    BIO_printf(hi->bioKeylog, "%s\n", line);
    (void)BIO_flush(hi->bioKeylog);
}
#endif

int HTTPInit(HHTTP hi, HDEV hDev)
{
    int ret;
    hi->hDev = hDev;
    if (!strlen(hi->modelTaAddr.szTaxAuthorityURL) || hi->modelTaAddr.bServType == TAADDR_NOT_SET)
        return ERR_PARM_CHECK;
    if (hi->modelTaAddr.bServType == TAADDR_CONFIRM) {
        //确认平台只需要简单初始化即可
        if (!(hi->ctx = SSL_CTX_new(TLS_client_method())))
            return ERR_PARM_INIT;
    } else {
        if ((ret = InitSSL(hi)) < 0)
            return ret;
    }
    SSL_CTX_set_app_data(hi->ctx, hi);
    hi->bufHttpRep = evbuffer_new();
    hi->bufCookies = evbuffer_new();
#ifdef _CONSOLE
    // openssl1.1新功能，记录的sslkeylog可以用wireshark解密查看ssl通信数据
    if (hi->ctx != NULL && hi->bioKeylog == NULL) {
        hi->bioKeylog = BIO_new_file("/mnt/hgfs/vtmp/sslkeylog", "a");
        if (!hi->bioKeylog)
            hi->bioKeylog = BIO_new_file("/tmp/sslkeylog", "a");
        if (hi->bioKeylog) {
            if (BIO_tell(hi->bioKeylog) == 0) {
                BIO_puts(hi->bioKeylog, "# SSL/TLS secrets log file, generated by OpenSSL\n");
                (void)BIO_flush(hi->bioKeylog);
            }
            SSL_CTX_set_keylog_callback(hi->ctx, SSLkeylogCallback);
        }
    }
#endif
    return 0;
}

//阻塞调用，可通过专用接口Break连接过程
int HTTPOpen(HHTTP hi)
{
    int ret = ERR_GENERIC;
    if (NULL == hi)
        return ERR_PARM_NULLPTR;
    if ((ret = EventInit(hi)) < 0)
        return ERR_IO_INIT;
    if ((ret = EventConnect(hi)) < 0)
        return ERR_IO_FAIL;
    //上述都是插入异步IO队列，如下loop进行域名查询和ssl建立
    EvenPendingWithBreakSingal(hi);
    if (hi->nHttpRepCode != 200)
        return ERR_IO_REPCHECK;
    return RET_SUCCESS;
}

void HTTPClose(HHTTP hi)
{
	if (hi->hDev != NULL)
	{
		char tmp_s[100] = { 0 };
		hi->hDev->DevHttp.end_time = get_time_msec();
		timer_read_asc_ms(tmp_s);
		memset(hi->hDev->DevHttp.end_time_s, 0, sizeof(hi->hDev->DevHttp.end_time_s));
		memcpy(hi->hDev->DevHttp.end_time_s, tmp_s + 1, 23);
		hi->hDev->DevHttp.time_consuming = hi->hDev->DevHttp.end_time - hi->hDev->DevHttp.start_time;
		if ((hi->hDev->hUSB->errcode == ErrorNET) && (strlen(hi->hDev->hUSB->errinfo) > 0))
		{
			hi->hDev->connect_failed_count += 1;
			hi->hDev->connect_failed_time += hi->hDev->DevHttp.time_consuming;
		}
		else
		{
			hi->hDev->connect_success_count += 1;
			hi->hDev->connect_success_time += hi->hDev->DevHttp.time_consuming;
		}
		hi->hDev->bBreakAllIO = 0;//清除缓存	
	}
    if (hi->ctxCfmReq.bLoginOK)
        ConfirmLogout(hi);
    if (hi->bufHttpRep)
        evbuffer_free(hi->bufHttpRep);
    if (hi->bufCookies)
        evbuffer_free(hi->bufCookies);
    if (hi->uri)
        evhttp_uri_free(hi->uri);
    if (hi->evConn)
        evhttp_connection_free(hi->evConn);
    if (hi->evDns)
        evdns_base_free(hi->evDns, 0);
    if (hi->evBreak)
        event_free(hi->evBreak);
    if (hi->evIoTimeout)
        event_free(hi->evIoTimeout);
    if (hi->evBase)
        event_base_free(hi->evBase);
    if (hi->ctx)
        SSL_CTX_free(hi->ctx);
#ifdef _CONSOLE
    if (hi->bioKeylog)
        BIO_free_all(hi->bioKeylog);
#endif
}

// evhttp_find_header找不全，例如湖北RSA上报服务器有多个SetCookie头，因此需要手动设置
void AppendAllCookies(HHTTP hi, const struct evkeyvalq *headers)
{
    struct evkeyval *kv = (struct evkeyval *)headers->tqh_first;
    while (kv) {
        do {
            if (!strcmp(kv->key, "Set-Cookie")) {
                char *p = (char *)evbuffer_pullup(hi->bufCookies, -1);
                if (p && strstr(p, kv->value))
                    break;  //已有该键值
                //追加cookies
                if (evbuffer_get_length(hi->bufCookies) != 0)
                    evbuffer_add(hi->bufCookies, ";", 1);
                evbuffer_add(hi->bufCookies, kv->value, strlen(kv->value));
            }
        } while (false);
        kv = kv->next.tqe_next;
    }
}

void GetNeedHttpHeader(HHTTP hi, struct evhttp_request *req)
{
    const char *szHeader = NULL;
    const struct evkeyvalq *headers = NULL;
    do {
        if (!(headers = evhttp_request_get_input_headers(req)))
            break;
        if (hi->nHttpRepCode != 200)
            break;
        AppendAllCookies(hi, headers);
        if ((szHeader = evhttp_find_header(headers, "AQJR_CLIENT_IP")) != NULL)
            strcpy(hi->hDev->szClientWanIP, (char *)szHeader);
        if ((szHeader = evhttp_find_header(headers, "AQJR_CLIENT_PORT")) != NULL)
            strcpy(hi->hDev->szClientWanPort, (char *)szHeader);  // cntax专用
    } while (false);
    //有的没有port,port信息包含在AQJR_CLIENT_IP中(nisec,aisino);
    char *p = strchr(hi->hDev->szClientWanIP, ':');
    if (p) {
        *p = '\0';
        strcpy(hi->hDev->szClientWanPort, p + 1);
    }
}

void GetHttpErrorCode(HHTTP hi)
{
    unsigned long oslerr;
    int errcode = EVUTIL_SOCKET_ERROR();
    char buffer[512] = "";
    struct bufferevent *bev = (struct bufferevent *)hi->evEvent;
    while ((oslerr = bufferevent_get_openssl_error(bev))) {
        ERR_error_string_n(oslerr, buffer, sizeof(buffer));
    }
    if (!strlen(buffer))
        sprintf(buffer, "HttpIO failed %s (%d)\n", evutil_socket_error_to_string(errcode), errcode);
    _WriteLog(LL_FATAL, "%s", buffer);
    SetLastError(hi->hDev->hUSB, ERR_IO_FAIL, buffer);
}

void GetHttpReponseCallback(struct evhttp_request *req, void *ctx)
{
    char buffer[4096];
    int nread;
    HHTTP hi = (HHTTP)ctx;
    if (!req || !evhttp_request_get_response_code(req)) {
        GetHttpErrorCode(hi);
        event_base_loopbreak(hi->evBase);
        return;
    }
    hi->nHttpRepCode = evhttp_request_get_response_code(req);
    GetNeedHttpHeader(hi, req);
    while ((nread = evbuffer_remove(evhttp_request_get_input_buffer(req), buffer, sizeof(buffer))) >
           0) {
        evbuffer_add(hi->bufHttpRep, buffer, nread);
    }
    //按照正常流程是需要继续等待几秒钟的pendding(evhttp_connection_set_timeout设置的值)才会结束HTTPS的IO
    //我们尚未启用HTTP长连接方式进行通信，因此每次读取完成后breakloop即可
    event_base_loopbreak(hi->evBase);
}

int SetHttpHostNode(struct evhttp_request *req, struct evhttp_uri *uri)
{
    const char *host, *scheme;
    char szHostNode[256];
    int port;
    scheme = evhttp_uri_get_scheme(uri);
    host = evhttp_uri_get_host(uri);
    port = evhttp_uri_get_port(uri);
    if (port == -1)
        port = (strcasecmp(scheme, "http") == 0) ? 80 : 443;
    sprintf(szHostNode, "%s:%d", host, port);
    evhttp_add_header(evhttp_request_get_output_headers(req), "Host", szHostNode);
    return 0;
}

void SetPostContent(struct evhttp_request *req, uint8 *pData, int nDataSize)
{
    char szBuf[16] = "";
    struct evbuffer *evbufOutput = evhttp_request_get_output_buffer(req);
    struct evkeyvalq *headerOutput = evhttp_request_get_output_headers(req);
    if (nDataSize < 1024) {
        evbuffer_add(evbufOutput, pData, nDataSize);
        evutil_snprintf(szBuf, sizeof(szBuf) - 1, "%u", (uint32)nDataSize);
        evhttp_add_header(headerOutput, "Content-Length", szBuf);
    } else {
        evhttp_add_header(headerOutput, "Expect", "100-continue");
        evbuffer_add(evbufOutput, pData, nDataSize);
    }
}

int SetCurrentCookies(struct evbuffer *bufCookies, struct evkeyvalq *headerOutput)
{
    int nCookiesSize = evbuffer_get_length(bufCookies);
    if (nCookiesSize != 0) {  // append '\0'
        char *pCookie = calloc(1, nCookiesSize + 1);
        if (pCookie) {
            strncpy(pCookie, (char *)evbuffer_pullup(bufCookies, -1), nCookiesSize);
            evhttp_add_header(headerOutput, "Cookie", pCookie);
            free(pCookie);
        } else
            _WriteLog(LL_WARN, "Set cookies memory alloc failed");
    }
    return 0;
}

//税局对提交的公网IP查的很严格，出错的按照异地开票论处，因此必须设置对
void RepairBadWanInfo(HDEV hDev)
{
    // nisec和cntax默认是""和"0"
    // aisino旧版本都为unknown,3.0后旧版本未知，保险起见先按照上面设置
    const char szDefaultIP[] = "";
    const char szDefaultPort[] = "0";
	if (IsPrivateIPv4(hDev->szClientWanIP))
	{
		char ip_tmp[100] = { 0 };
		read_file("/etc/ip_tmp.txt", ip_tmp, sizeof(ip_tmp));
		
		memset(hDev->szClientWanIP, 0, sizeof(hDev->szClientWanIP));
		memset(hDev->szClientWanPort, 0, sizeof(hDev->szClientWanPort));
		if (strlen(ip_tmp) > 0)
		{
			strcpy(hDev->szClientWanIP, (char *)ip_tmp);
			strcpy(hDev->szClientWanPort, (char *)"32813");
		}
		else
		{
			strcpy(hDev->szClientWanIP, szDefaultIP);
			strcpy(hDev->szClientWanPort, szDefaultPort);
		}
		//_WriteLog(LL_INFO, "changed ip:%s,port:%s", hDev->szClientWanIP, hDev->szClientWanPort);
	}
}

int HttpIoResponse(HHTTP hi, bool bGetPost, char *szQueryPathInput, uint8 *data, int nDataSize)
{
    struct evhttp_request *req;
    char szQueryPath[512] = "";
    evbuffer_drain(hi->bufHttpRep, evbuffer_get_length(hi->bufHttpRep));
    if (!(req = evhttp_request_new(GetHttpReponseCallback, hi)))
        return ERR_PARM_INIT;
    struct evkeyvalq *headerOutput = evhttp_request_get_output_headers(req);
    if (!bGetPost)  // POST
        evhttp_add_header(headerOutput, "Content-Type", "application/x-www-form-urlencoded");
    strcpy(szQueryPath, szQueryPathInput);
    //可以不用，加上更贴近
    evhttp_add_header(headerOutput, "User-Agent", "Mozilla/5.0 AppleWebKit/537.36");
    //追加host头
    SetHttpHostNode(req, hi->uri);
    //追加已有的认证cookies
    SetCurrentCookies(hi->bufCookies, headerOutput);
    if (!bGetPost)
        SetPostContent(req, data, nDataSize);

    /*struct evkeyval *header;		                // 用来保存HTTP headers的队列

    for (header = headerOutput->tqh_first; header; header = header->next.tqe_next) 
    {
        printf("key = %s  value = %s\r\n",header->key,header->value);
    }
    printf("szQueryPath = %s\r\n",szQueryPath);       //请求地址*/

    if (evhttp_make_request(hi->evConn, req, bGetPost ? EVHTTP_REQ_GET : EVHTTP_REQ_POST,
                            szQueryPath) != 0)
        return ERR_PARM_INIT;
    EvenPendingWithBreakSingal(hi);
    // IO结束后对税局给的IP端口进行修正
    RepairBadWanInfo(hi->hDev);
    return RET_SUCCESS;
}

int HTTPPostEvent(HHTTP hi, char *szQueryPath, uint8 *data, int nDataSize)
{
    int nRet = 0;
    if ((nRet = HttpIoResponse(hi, false, szQueryPath, data, nDataSize)) < 0)
        return nRet;
    int nRepSize = evbuffer_get_length(hi->bufHttpRep);
    if (hi->nHttpRepCode != 200 || nRepSize <= 0) {
        _WriteLog(LL_WARN, "Http Post check response failed, HttpCode:%d nRepSize:%d",
                  hi->nHttpRepCode, nRepSize);
        return ERR_TA_REPONSE_CHECK;
    }
    return nRepSize;
}

int HTTPGetEvent(HHTTP hi, char *szQueryPath)
{
    int nRet = 0;
    if ((nRet = HttpIoResponse(hi, true, szQueryPath, NULL, 0)) < 0)
        return nRet;
    int nRepSize = evbuffer_get_length(hi->bufHttpRep);
    if (hi->nHttpRepCode != 200 || nRepSize <= 0)
        return ERR_TA_REPONSE_CHECK;
    return nRepSize;
}

int HTTPPost(HHTTP hi, char *szQueryPath, char *pData, int nDataLen, char *response,
             int repBufferLen)
{
    int nChildRet = 0, nRet = 0, nRepSize = 0;
    do {
        if ((nChildRet = HTTPPostEvent(hi, szQueryPath, (uint8 *)pData, nDataLen)) < 0) {
            nRet = nChildRet;
            break;
        }
        nRepSize = nChildRet;
        if (nRepSize + 1 > repBufferLen) {
            nRet = ERR_BUF_OVERFLOW;
            _WriteLog(LL_FATAL, "Buffer overflow, small buf");
            break;
        }
        strncpy(response, (char *)evbuffer_pullup(hi->bufHttpRep, -1), nRepSize);
        response[nRepSize] = '\0';
        nRet = nRepSize;
    } while (false);
    return nRet;
}

//全电HTTP函数

#ifdef _CONSOLE
void EtaxSSLkeylogCallback(const SSL *ssl, const char *line)
{
    SSL_CTX *ctx = SSL_get_SSL_CTX(ssl);
    EHHTTP hi = SSL_CTX_get_app_data(ctx);
    if (!hi)
        return;
    if (!hi->bioKeylog)
        return;
    BIO_printf(hi->bioKeylog, "%s\n", line);
    (void)BIO_flush(hi->bioKeylog);
}
#endif

int EtaxSelectSslInitType(EHHTTP hi)
{
    int ret = RET_SUCCESS;
    if (hi->modelTaAddr.bServType == TAADDR_NOT_SET) {
        ret = ERR_PARM_INIT;
        _WriteLog(LL_FATAL, "Must set Ta server's URL");
    } else if (hi->modelTaAddr.bServType == TAADDR_UPLOAD_RSA ||
               hi->modelTaAddr.bServType == TAADDR_PLATFORM ||
               hi->modelTaAddr.bServType == TAADDR_UPLOAD_GM) {
        //经典税局开票平台
        ret = EtaxInitSSL(hi);
    } else {
        //基于网页的连接，基本都是RSA认证，常规浏览器单向认证，只需要简单初始化即可
        if (!(hi->ctxCon.ctxSsl = SSL_CTX_new(TLS_client_method())))
            ret = ERR_PARM_INIT;
    }
    return ret;
}

int EtaxHTTPInit(EHHTTP hi, HDEV hDev)
{
    int ret = ERR_GENERIC;
    hi->hDev = hDev;
    if (!strlen(hi->modelTaAddr.szTaxAuthorityURL) || hi->modelTaAddr.bServType == TAADDR_NOT_SET)
        return ERR_PARM_CHECK;
    if ((ret = EtaxSelectSslInitType(hi)))
        return ret;
    SSL_CTX_set_app_data(hi->ctxCon.ctxSsl, hi);
    hi->bufHttpRep = evbuffer_new();
    hi->ctxCon.bufCookies = evbuffer_new();
    hi->ctxCon.bufLocation = evbuffer_new();
#ifdef _CONSOLE
    // openssl1.1新功能，记录的sslkeylog可以用wireshark解密查看ssl通信数据
    if (hi->ctxCon.ctxSsl != NULL && hi->bioKeylog == NULL) {
        hi->bioKeylog = BIO_new_file("/mnt/hgfs/vtmp/sslkeylog", "a");
        if (!hi->bioKeylog)
            hi->bioKeylog = BIO_new_file("/tmp/sslkeylog", "a");
        if (hi->bioKeylog) {
            if (BIO_tell(hi->bioKeylog) == 0) {
                BIO_puts(hi->bioKeylog, "# SSL/TLS secrets log file, generated by OpenSSL\n");
                (void)BIO_flush(hi->bioKeylog);
            }
            SSL_CTX_set_keylog_callback(hi->ctxCon.ctxSsl, SSLkeylogCallback);
        }
    }
#endif
    return RET_SUCCESS;
}

//阻塞调用，可通过专用接口Break连接过程
int EtaxHTTPOpen(EHHTTP hi)
{
    int ret = ERR_GENERIC;
    if (NULL == hi)
        return ERR_PARM_NULLPTR;
    if ((ret = EtaxEventInit(hi)) < 0)
        return ERR_IO_INIT;
    if ((ret = EtaxEventConnect(hi)) < 0)
        return ERR_IO_FAIL;
    //上述都是插入异步IO队列，如下loop进行域名查询和ssl建立
    EtaxEvenPendingWithBreakSingal(hi);
    // if (hi->ctxCon.nHttpRepCode != 200 && hi->ctxCon.nHttpRepCode != 302)
    //     return ERR_IO_REPCHECK;
    return RET_SUCCESS;
}

void EtaxHTTPClose(EHHTTP hi)
{
	if (hi->hDev != NULL)
	{
		char tmp_s[100] = { 0 };
		hi->hDev->DevHttp.end_time = get_time_msec();
		timer_read_asc_ms(tmp_s);
		memset(hi->hDev->DevHttp.end_time_s, 0, sizeof(hi->hDev->DevHttp.end_time_s));
		memcpy(hi->hDev->DevHttp.end_time_s, tmp_s + 1, 23);
		hi->hDev->DevHttp.time_consuming = hi->hDev->DevHttp.end_time - hi->hDev->DevHttp.start_time;
		if ((hi->hDev->hUSB->errcode == ErrorNET) && (strlen(hi->hDev->hUSB->errinfo) > 0))
		{
			hi->hDev->connect_failed_count += 1;
			hi->hDev->connect_failed_time += hi->hDev->DevHttp.time_consuming;
		}
		else
		{
			hi->hDev->connect_success_count += 1;
			hi->hDev->connect_success_time += hi->hDev->DevHttp.time_consuming;
		}
		hi->hDev->bBreakAllIO = 0;//清除缓存	
	}
    if (hi->cbHttpClose)
        hi->cbHttpClose(hi);
    if (hi->bufHttpRep)
        evbuffer_free(hi->bufHttpRep);
    if (hi->ctxCon.uriLocation)
        evhttp_uri_free(hi->ctxCon.uriLocation);
    if (hi->ctxCon.bufCookies)
        evbuffer_free(hi->ctxCon.bufCookies);
    if (hi->ctxCon.bufLocation)
        evbuffer_free(hi->ctxCon.bufLocation);
    if (hi->ctxCon.uri)
        evhttp_uri_free(hi->ctxCon.uri);
    if (hi->ctxCon.evConn)
        evhttp_connection_free(hi->ctxCon.evConn);
    if (hi->ctxCon.evDns)
        evdns_base_free(hi->ctxCon.evDns, 0);
    if (hi->ctxCon.evBreak)
        event_free(hi->ctxCon.evBreak);
    if (hi->ctxCon.evIoTimeout)
        event_free(hi->ctxCon.evIoTimeout);
    if (hi->ctxCon.evBase)
        event_base_free(hi->ctxCon.evBase);
    if (hi->ctxCon.ctxSsl)
        SSL_CTX_free(hi->ctxCon.ctxSsl);
#ifdef _CONSOLE
    if (hi->bioKeylog)
        BIO_free_all(hi->bioKeylog);
#endif
}

void EtaxUpdateEvPairKeyValue(struct evkeyvalq *cookiesPairs, char *key, char *value)
{
    if (evhttp_find_header(cookiesPairs, key))
        evhttp_remove_header(cookiesPairs, key);
    evhttp_add_header(cookiesPairs, key, value);
    return;
}

// a=1;b=2;c=3;a=4   后面一个a4替换掉第一个a=3;b=2;c=3;
void EtaxRemoveRepeatOldCookies(struct evbuffer *evBufCookies)
{
    bool bHasCookiesUpdate = false;
    if (!evbuffer_get_length(evBufCookies))
        return;
    struct evkeyvalq cookiesPairs;
    TAILQ_INIT(&cookiesPairs);
    SplitInfo spOut;
    memset(&spOut, 0, sizeof(SplitInfo));
    GetSplitString((char *)evbuffer_pullup(evBufCookies, -1), "; ", &spOut);
    SplitInfo *pOut = &spOut;
    int i;
    for (i = 0; i < spOut.num; i++) {
        pOut = pOut->next;
        char *pChild = strdup(pOut->info);
        if (!pChild)
            continue;
        char *pSep = strchr(pChild, '=');
        if (!pSep)
            EtaxUpdateEvPairKeyValue(&cookiesPairs, pChild, "");
        else {
            *pSep = '\0';
            EtaxUpdateEvPairKeyValue(&cookiesPairs, pChild, pSep + 1);
        }
        bHasCookiesUpdate = true;
        free(pChild);
    }
    SplitFree(&spOut);
    if (bHasCookiesUpdate) {
        evbuffer_drain(evBufCookies, -1);
        struct evkeyval *kv = (struct evkeyval *)cookiesPairs.tqh_first;
        while (kv) {
            if (evbuffer_get_length(evBufCookies) != 0)
                evbuffer_add(evBufCookies, "; ", 2);
            evbuffer_add_printf(evBufCookies, "%s%s%s", kv->key, strlen(kv->value) == 0 ? "" : "=",
                                kv->value);
            kv = kv->next.tqe_next;
        }
    }
    evhttp_clear_headers(&cookiesPairs);
}

// evhttp_find_header找不全，例如湖北RSA上报服务器有多个SetCookie头，因此需要手动设置
void EtaxAppendAllCookies(EHHTTP hi, const struct evkeyvalq *headers)
{
    struct evkeyval *kv = (struct evkeyval *)headers->tqh_first;
    bool bNewCookiesAppend = false;
    while (kv) {
        do {
            //不同的服务器对set-cookie命名有大小写区别
            if (strcmp(kv->key, "Set-Cookie") && strcmp(kv->key, "set-cookie"))
                break;
            char *p = (char *)evbuffer_pullup(hi->ctxCon.bufCookies, -1);
            if (p && strstr(p, kv->value))
                break;  //已有该键值
            //_WriteLog(LL_DEBUG, "Append cookies:%s", kv->value);
            //追加cookies
            if (evbuffer_get_length(hi->ctxCon.bufCookies) != 0)
                evbuffer_add(hi->ctxCon.bufCookies, "; ", 2);
            //不能用evbuffer_add,需要使用evbuffer_add_printf保持末尾为\0
            evbuffer_add_printf(hi->ctxCon.bufCookies, "%s", kv->value);
            bNewCookiesAppend = true;
        } while (false);
        kv = kv->next.tqe_next;
    }
    if (bNewCookiesAppend)
        EtaxRemoveRepeatOldCookies(hi->ctxCon.bufCookies);
}

void EtaxGetNeedHttpHeader(EHHTTP hi, struct evkeyvalq *headers)
{
    const char *szHeader = NULL;
    do {
        if (hi->ctxCon.nHttpRepCode != 200 && hi->ctxCon.nHttpRepCode != 302)
            break;
        EtaxAppendAllCookies(hi, headers);
        if ((szHeader = evhttp_find_header(headers, "AQJR_CLIENT_IP")) != NULL)
            strcpy(hi->hDev->szClientWanIP, (char *)szHeader);
        if ((szHeader = evhttp_find_header(headers, "AQJR_CLIENT_PORT")) != NULL)
            strcpy(hi->hDev->szClientWanPort, (char *)szHeader);  // cntax专用
    } while (false);
    //有的没有port,port信息包含在AQJR_CLIENT_IP中(nisec,aisino);
    char *p = strchr(hi->hDev->szClientWanIP, ':');
    if (p) {
        *p = '\0';
        strcpy(hi->hDev->szClientWanPort, p + 1);
    }
}

void EtaxGetHttpErrorCode(EHHTTP hi)
{
    unsigned long oslerr;
    int errcode = EVUTIL_SOCKET_ERROR();
    char buffer[512] = "";
    struct bufferevent *bev = (struct bufferevent *)hi->ctxCon.evEvent;
    while ((oslerr = bufferevent_get_openssl_error(bev))) {
        ERR_error_string_n(oslerr, buffer, sizeof(buffer));
    }
    if (!strlen(buffer))
        sprintf(buffer, "HttpIO failed %s (%d)\n", evutil_socket_error_to_string(errcode), errcode);
    _WriteLog(LL_FATAL, "%s", buffer);
    SetLastError(hi->hDev->hUSB, ERR_IO_FAIL, buffer);
}

// decode gzip
int EtaxDeCompressBody(EHHTTP hi, struct evkeyvalq *headers)
{
    int nRet = ERR_GENERIC, nChildRet = ERR_GENERIC;
    const char *szHeader = NULL;
    do {
        if (!(szHeader = (char *)evhttp_find_header(headers, "content-encoding")))
            break;
        //实际也是可以支持deflate的，即zlib标准算法，但是目前还没遇到
        //目前先实现使用率最高的gzip=lz77算法，nginx(新版上海电子税务局用到)
        if (evutil_ascii_strcasecmp(szHeader, "gzip"))
            break;
        nRet = GzipDecompress(hi->bufHttpRep);
    } while (false);
    return nRet;
}

bool EtaxParseReponseCode(EHHTTP hi, struct evhttp_request *req, struct evkeyvalq *headers)
{
    bool ret = false;
    char *szHeader = NULL;
    char *tmp_ptr = NULL;
    do {
        hi->ctxCon.nHttpRepCode = evhttp_request_get_response_code(req);
        if (302 == hi->ctxCon.nHttpRepCode) {
            if (!(szHeader = (char *)evhttp_find_header(headers, "Location")))
                break;
            if (!strlen(szHeader))
                break;
            //_WriteLog(LL_DEBUG, "Server reponse location:%s", szHeader);
            if (hi->ctxCon.uriLocation) {
                evhttp_uri_free(hi->ctxCon.uriLocation);
                hi->ctxCon.uriLocation = NULL;
            }

            tmp_ptr = (char *)calloc(1,strlen(szHeader) + 1);
            strcpy(tmp_ptr,szHeader);
            if(hi->user_args)
            {
                free(hi->user_args);
                hi->user_args = NULL;
            }
            hi->user_args = (void *)tmp_ptr; //将location的数据保存到user_args
            // Tolerate URIs that do not conform to RFC3986. Unfortunately, some HTTP clients
            // generate URIs that, according to RFC3986,
            // are not conformant URIs.  If you need to support these URIs, you can do so by passing
            // this flag to evhttp_uri_parse_with_flags.
            //部分重定向url非正式，可关掉url合法性检查，内部使用去掉一切URL合法检查，只做URL解析
            // evhttp_uri_parse_with_flags(szHeader, EVHTTP_URI_NONCONFORMANT)
            if (!(hi->ctxCon.uriLocation = evhttp_uri_parse(szHeader)))
                break;
            evbuffer_add_printf(hi->ctxCon.bufLocation, "%s", szHeader);
        }
        ret = true;
    } while (false);
    return ret;
}

void EtaxGetHttpReponseCallback(struct evhttp_request *req, void *ctx)
{
    char buffer[4096];
    int nread = 0;
    EHHTTP hi = (EHHTTP)ctx;
    struct evkeyvalq *headers = NULL;
    bool bReponseSuccessful = false;
    do {
        if (!req) {
            EtaxGetHttpErrorCode(hi);
            break;
        }
        if (!(headers = evhttp_request_get_input_headers(req))) {
            SetLastError(hi->hDev->hUSB, ERR_IO_FAIL, "Not found header");
            break;
        }
        if (!EtaxParseReponseCode(hi, req, headers))
            break;
        EtaxGetNeedHttpHeader(hi, headers);
        while ((nread = evbuffer_remove(evhttp_request_get_input_buffer(req), buffer,
                                        sizeof(buffer))) > 0) {
            evbuffer_add(hi->bufHttpRep, buffer, nread);
        }
        EtaxDeCompressBody(hi, headers);
        if (hi->cbHttpReponse && (hi->cbHttpReponse(hi, req, headers) < 0))
            break;
        bReponseSuccessful = true;
    } while (false);
    hi->ctxCon.bReponseCallbackCheckFail = !bReponseSuccessful;
    //按照正常流程是需要继续等待几秒钟的pendding(evhttp_connection_set_timeout设置的值)才会结束HTTPS的IO
    //我们尚未启用HTTP长连接方式进行通信，因此每次读取完成后breakloop即可
    event_base_loopbreak(hi->ctxCon.evBase);
}

int EtaxSetHttpHostNode(struct evhttp_request *req, struct evhttp_uri *uri)
{
    const char *host, *scheme;
    char szHostNode[256];
    int port;
    scheme = evhttp_uri_get_scheme(uri);
    host = evhttp_uri_get_host(uri);
    port = evhttp_uri_get_port(uri);
    if (port == -1)
        port = (strcasecmp(scheme, "http") == 0) ? 80 : 443;
    sprintf(szHostNode, "%s:%d", host, port);
    evhttp_add_header(evhttp_request_get_output_headers(req), "Host", szHostNode);
    return 0;
}

void EtaxSetPostContent(struct evhttp_request *req, uint8 *pData, int nDataSize)
{
    char szBuf[16] = "";
    struct evbuffer *evbufOutput = evhttp_request_get_output_buffer(req);
    struct evkeyvalq *headerOutput = evhttp_request_get_output_headers(req);
    if (nDataSize < 1024) {
        evbuffer_add(evbufOutput, pData, nDataSize);
        evutil_snprintf(szBuf, sizeof(szBuf) - 1, "%u", (uint32)nDataSize);
        evhttp_add_header(headerOutput, "Content-Length", szBuf);
    } else {
        evhttp_add_header(headerOutput, "Expect", "100-continue");
        evbuffer_add(evbufOutput, pData, nDataSize);
    }
}

int EtaxSetCurrentCookies(struct evbuffer *bufCookies, struct evkeyvalq *headerOutput)
{
    int nCookiesSize = evbuffer_get_length(bufCookies);
    if (nCookiesSize != 0) {  // append '\0'
        char *pCookie = calloc(1, nCookiesSize + 1);
        if (pCookie) {
            strncpy(pCookie, (char *)evbuffer_pullup(bufCookies, -1), nCookiesSize);
            evhttp_add_header(headerOutput, "Cookie", pCookie);
            free(pCookie);
        } else
            _WriteLog(LL_WARN, "Set cookies memory alloc failed");
    }
    return 0;
}

//税局对提交的公网IP查的很严格，出错的按照异地开票论处，因此必须设置对
void EtaxRepairBadWanInfo(HDEV hDev)
{
    // nisec和cntax默认是""和"0"
    // aisino旧版本都为unknown,3.0后旧版本未知，保险起见先按照上面设置
    const char szDefaultIP[] = "";
    const char szDefaultPort[] = "0";
	if (IsPrivateIPv4(hDev->szClientWanIP))
	{
		char ip_tmp[100] = { 0 };
		read_file("/etc/ip_tmp.txt", ip_tmp, sizeof(ip_tmp));
		
		memset(hDev->szClientWanIP, 0, sizeof(hDev->szClientWanIP));
		memset(hDev->szClientWanPort, 0, sizeof(hDev->szClientWanPort));
		if (strlen(ip_tmp) > 0)
		{
			strcpy(hDev->szClientWanIP, (char *)ip_tmp);
			strcpy(hDev->szClientWanPort, (char *)"32813");
		}
		else
		{
			strcpy(hDev->szClientWanIP, szDefaultIP);
			strcpy(hDev->szClientWanPort, szDefaultPort);
		}
		//_WriteLog(LL_INFO, "changed ip:%s,port:%s", hDev->szClientWanIP, hDev->szClientWanPort);
	}
}

int EtaxHttpIoResponse(EHHTTP hi, bool bGetPost, char *szQueryPathInput, char *szContentType,
                   uint8 *data, int nDataSize)
{
    int nRepSize = 0;
    struct evhttp_request *req = NULL;
    char szQueryPath[512] = "";
    evbuffer_drain(hi->bufHttpRep, evbuffer_get_length(hi->bufHttpRep));
    if (!(req = evhttp_request_new(EtaxGetHttpReponseCallback, hi)))
        return ERR_PARM_INIT;
    //存在cbHttpNewReq回调时才执行
    if (hi->cbHttpNewReq && hi->cbHttpNewReq(hi, req))
        return ERR_PARM_INIT;
    struct evkeyvalq *headerOutput = evhttp_request_get_output_headers(req);
    if (!bGetPost && strlen(szContentType))  // POST
        evhttp_add_header(headerOutput, "Content-Type", szContentType);
    strcpy(szQueryPath, szQueryPathInput);
    //可以不用，加上更贴近
    evhttp_add_header(
        headerOutput, "User-Agent",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/112.0.0.0");
    //针对http协议大容量传输，启用gzip压缩;上海新版税务局默认启用
    // gzip – GNU zip格式（定义于RFC 1952）。此方法截至2011年3月，是应用程序支持最广泛的方法。
    //注释该行，可以查看明文数据通信
    evhttp_add_header(headerOutput, "Accept-Encoding", "gzip");
    hi->ctxCon.bReponseCallbackCheckFail = false;
    //追加host头
    SetHttpHostNode(req, hi->ctxCon.uri);
    //追加已有的认证cookies
    SetCurrentCookies(hi->ctxCon.bufCookies, headerOutput);
    if (!bGetPost)
        SetPostContent(req, data, nDataSize);

    // struct evkeyval *header;		                // 用来保存HTTP headers的队列

    // for (header = headerOutput->tqh_first; header; header = header->next.tqe_next) 
    // {
    //     printf("key = %s  value = %s\r\n",header->key,header->value);
    // }
    // printf("szQueryPath = %s\r\n",szQueryPath);       //请求地址

    if (evhttp_make_request(hi->ctxCon.evConn, req, bGetPost ? EVHTTP_REQ_GET : EVHTTP_REQ_POST,
                            szQueryPath) != 0)
        return ERR_PARM_INIT;
    EtaxEvenPendingWithBreakSingal(hi);
    // IO结束后对税局给的IP端口进行修正
    RepairBadWanInfo(hi->hDev);
    //返回检测
    nRepSize = evbuffer_get_length(hi->bufHttpRep);
    if (nRepSize) {
        //方便外部调用evbuff_pullup，加入\0截断，不影响返回长度，但是evbuffer_get_length长度增加1
        uint8 b0 = 0x00;
        evbuffer_add(hi->bufHttpRep, &b0, 1);
        //此时evbuffer_get_length长度变化
    }
    if (hi->ctxCon.bReponseCallbackCheckFail)
        return ERR_TA_REPONSE_CHECK;
    // 302时跳转，nRepSize==0
    if ((hi->ctxCon.nHttpRepCode != 200 && hi->ctxCon.nHttpRepCode != 302) || nRepSize < 0)
        return ERR_TA_REPONSE_CHECK;
    return nRepSize;
}


int EtaxHttpIoResponsedown(EHHTTP hi, bool bGetPost, char *szQueryPathInput, char *szContentType,
                   uint8 *data, int nDataSize)
{
    int nRepSize = 0;
    struct evhttp_request *req = NULL;
    char szQueryPath[512] = "";
    evbuffer_drain(hi->bufHttpRep, evbuffer_get_length(hi->bufHttpRep));
    if (!(req = evhttp_request_new(EtaxGetHttpReponseCallback, hi)))
        return ERR_PARM_INIT;
    //存在cbHttpNewReq回调时才执行
    if (hi->cbHttpNewReq && hi->cbHttpNewReq(hi, req))
        return ERR_PARM_INIT;
    struct evkeyvalq *headerOutput = evhttp_request_get_output_headers(req);
    //if (!bGetPost && strlen(szContentType))  // POST
    evhttp_add_header(headerOutput, "Content-Type", "application/pdf;charset=utf-8");
    strcpy(szQueryPath, szQueryPathInput);
    //可以不用，加上更贴近
    evhttp_add_header(headerOutput, "User-Agent", "Mozilla/5.0 AppleWebKit/537.36");
    //针对http协议大容量传输，启用gzip压缩;上海新版税务局默认启用
    // gzip – GNU zip格式（定义于RFC 1952）。此方法截至2011年3月，是应用程序支持最广泛的方法。
    //注释该行，可以查看明文数据通信
    evhttp_add_header(headerOutput, "Accept-Encoding", "gzip");
    hi->ctxCon.bReponseCallbackCheckFail = false;
    //追加host头
    SetHttpHostNode(req, hi->ctxCon.uri);
    //追加已有的认证cookies
    SetCurrentCookies(hi->ctxCon.bufCookies, headerOutput);
    if (!bGetPost)
        SetPostContent(req, data, nDataSize);

    /*struct evkeyval *header;		                // 用来保存HTTP headers的队列

    for (header = headerOutput->tqh_first; header; header = header->next.tqe_next) 
    {
        printf("key = %s  value = %s\r\n",header->key,header->value);
    }
    printf("szQueryPath = %s\r\n",szQueryPath);       //请求地址*/

    if (evhttp_make_request(hi->ctxCon.evConn, req, bGetPost ? EVHTTP_REQ_GET : EVHTTP_REQ_POST,
                            szQueryPath) != 0)
        return ERR_PARM_INIT;
    EtaxEvenPendingWithBreakSingal(hi);
    // IO结束后对税局给的IP端口进行修正
    RepairBadWanInfo(hi->hDev);
    //返回检测
    nRepSize = evbuffer_get_length(hi->bufHttpRep);
    if (nRepSize) {
        //方便外部调用evbuff_pullup，加入\0截断，不影响返回长度，但是evbuffer_get_length长度增加1
        uint8 b0 = 0x00;
        evbuffer_add(hi->bufHttpRep, &b0, 1);
        //此时evbuffer_get_length长度变化
    }
    if (hi->ctxCon.bReponseCallbackCheckFail)
        return ERR_TA_REPONSE_CHECK;
    // 302时跳转，nRepSize==0
    if ((hi->ctxCon.nHttpRepCode != 200 && hi->ctxCon.nHttpRepCode != 302) || nRepSize < 0)
        return ERR_TA_REPONSE_CHECK;
    return nRepSize;
}

int EtaxHTTPPostEvent(EHHTTP hi, char *szQueryPath, char *szContentType, uint8 *data, int nDataSize)
{
    return EtaxHttpIoResponse(hi, false, szQueryPath, szContentType, data, nDataSize);
}

//注意，返回长度应该根据Return返回值，而不是evbuffer_get_length的值，一般情况下多一个\0截断
int EtaxHTTPGetEvent(EHHTTP hi, char *szQueryPath)
{
    return EtaxHttpIoResponse(hi, true, szQueryPath, "", NULL, 0);
}

int EtaxHTTPGetEventdown(EHHTTP hi, char *szQueryPath)
{
    return EtaxHttpIoResponsedown(hi, true, szQueryPath, "", NULL, 0);
}

int EtaxHTTPPost(EHHTTP hi, char *szQueryPath, char *szContentType, char *pData, int nDataLen,
             char *response, int repBufferLen)
{
    int nChildRet = 0, nRet = 0;
    do {
        if ((nChildRet = EtaxHTTPPostEvent(hi, szQueryPath, szContentType, (uint8 *)pData, nDataLen)) <
            0) {
            nRet = nChildRet;
            break;
        }
        printf("__________nChildRet  = %d \r\n",nChildRet);
        if (nChildRet >= repBufferLen) {
            nRet = ERR_BUF_OVERFLOW;
            _WriteLog(LL_FATAL, "Buffer overflow, small buf,nChildRet=%d,repBufferLen=%d",nChildRet,repBufferLen);
            break;
        }
        if( (hi->bufHttpRep) != NULL){
            strncpy(response, (char *)evbuffer_pullup(hi->bufHttpRep, -1), nChildRet);
            response[nChildRet] = '\0';
        }
        nRet = nChildRet;
    } while (false);
    return nRet;
}
